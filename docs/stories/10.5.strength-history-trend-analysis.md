# Story 10.5: 强度历史趋势分析

Status: in-progress

## Story

作为一名 数据分析师，
我需要 实现强度历史趋势分析功能，以便 用户可以了解股票或板块强度的变化趋势、识别关键转折点和进行对比分析。

## Acceptance Criteria

1. ✅ 实现历史数据持久化存储（每日快照）
2. ✅ 实现趋势特征识别功能（上升、下降、震荡）
3. ⬜ 实现关键转折点检测（波峰、波谷、突破）
4. ⬜ 实现统计功能（最大值、最小值、平均值、标准差）
5. ⬜ 实现对比分析功能（多只股票对比、板块对比）
6. ⬜ 实现可视化数据准备（图表数据格式）
7. ⬜ 实现趋势预警功能（强度突变检测）
8. ⬜ 添加完整的单元测试和集成测试

## Tasks / Subtasks

### 1. 历史数据存储 (AC: 1)

- [x] 创建 `server/src/services/strength_snapshot_service.py`
  - [x] 实现 `create_daily_snapshot(date: date) -> None`
    - [x] 遍历所有股票和板块
    - [x] 计算当日强度
    - [x] 保存到 `strength_scores` 表
    - [x] 设置 period='all'
    - [x] 更新排名和百分位
  - [x] 实现 `batch_create_snapshots(start_date: date, end_date: date) -> None`
    - [x] 批量创建多日快照
    - [x] 使用异步并发
    - [x] 进度跟踪
  - [ ] 实现定时任务
    - [ ] 每日收盘后自动创建快照
    - [ ] 使用 APScheduler 或 Celery
    - [ ] 失败重试机制

### 2. 趋势特征识别 (AC: 2)

- [x] 创建 `server/src/services/trend_analysis_service.py`
  - [x] 实现 `identify_trend(history_data: List) -> Dict`
    - [x] 计算线性回归斜率
    - [x] 判断趋势方向
    - [x] 趋势强度评估
    - [x] 返回趋势类型：上升/下降/震荡
  - [x] 实现 `calculate_moving_avg_trend(scores: List, window: int) -> List`
    - [x] 计算移动平均线
    - [x] 判断均线方向
    - [x] 支持多周期均线（5日、10日、20日）
  - [x] 实现 `detect_consolidation(scores: List) -> bool`
    - [x] 检测横盘整理
    - [x] 波动率低于阈值
    - [x] 返回整理区间
  - [x] 趋势类型定义：
    ```python
    TREND_TYPES = {
        "strong_up": "强势上涨",      # 斜率 > 0.5
         "up": "上涨",               # 斜率 > 0.1
         "neutral": "震荡",          # -0.1 < 斜率 < 0.1
         "down": "下跌",             # 斜率 < -0.1
         "strong_down": "强势下跌"    # 斜率 < -0.5
    }
    ```

### 3. 关键转折点检测 (AC: 3)

**依赖**: 需要 `scipy` 库用于峰值检测算法（`find_peaks`）
- 安装: `pip install scipy`
- 或添加到 `requirements.txt`: `scipy>=1.11.0`

- [ ] 创建 `server/src/services/turning_point_service.py`
  - [ ] 实现 `find_peaks(scores: List, dates: List) -> List[Dict]`
    - [ ] 使用峰值检测算法
    - [ ] 返回波峰位置和值
    - [ ] 标记重要程度（局部/全局）
  - [ ] 实现 `find_valleys(scores: List, dates: List) -> List[Dict]`
    - [ ] 检测波谷位置
    - [ ] 返回波谷数据
  - [ ] 实现 `detect_breakthrough(current_score, history_scores, threshold=70) -> Dict`
    - [ ] 检测向上突破（突破关键等级）
    - [ ] 检测向下突破
    - [ ] 返回突破类型和强度
  - [ ] 实现 `find_inflection_points(scores: List, dates: List) -> List[Dict]`
    - [ ] 检测二阶导数变化点
    - [ ] 识别趋势反转点

### 4. 统计功能 (AC: 4)

- [ ] 创建 `server/src/services/strength_statistics_service.py`
  - [ ] 实现 `calculate_basic_stats(scores: List) -> Dict`
    - [ ] 最大值和日期
    - [ ] 最小值和日期
    - [ ] 平均值
    - [ ] 中位数
    - [ ] 标准差
    - [ ] 变异系数
  - [ ] 实现 `calculate_grade_distribution(history: List) -> Dict`
    - [ ] 各等级出现次数
    - [ ] 各等级占比
    - [ ] 最常见等级
    - [ ] 等级变化次数
  - [ ] 实现 `calculate_volatility(scores: List) -> float`
    - [ ] 计算波动率
    - [ ] 使用标准差或 ATR
  - [ ] 实现 `calculate_momentum(scores: List, period: int) -> float`
    - [ ] 计算动量指标
    - [ ] ROC（变化率）
    - [ ] 支持多周期

### 5. 对比分析功能 (AC: 5)

- [ ] 创建 `server/src/services/comparison_service.py`
  - [ ] 实现 `compare_stocks(stock_ids: List[int], days: int, db: Session) -> Dict`
    - [ ] 获取多只股票历史数据
    - [ ] 计算相对表现
    - [ ] 识别领先/滞后
    - [ ] 相关性分析
  - [ ] 实现 `compare_sectors(sector_ids: List[int], days: int, db: Session) -> Dict`
    - [ ] 板块间对比
    - [ ] 强弱排序
  - [ ] 实现 `compare_stock_to_sector(stock_id: int, sector_id: int, days: int) -> Dict`
    - [ ] 个股与板块对比
    - [ ] 相对强度
    - [ ] 超额表现
  - [ ] 实现 `calculate_correlation(data1: List, data2: List) -> float`
    - [ ] 皮尔逊相关系数
    - [ ] 滚动相关系数

### 6. 可视化数据准备 (AC: 6)

- [ ] 创建 `server/src/services/visualization_data_service.py`
  - [ ] 实现 `prepare_chart_data(entity_id: int, days: int, db: Session) -> Dict`
    - [ ] ECharts 格式数据
    - [ ] 图表类型配置
    - [ ] 颜色主题
  - [ ] 实现 `prepare_comparison_chart_data(entity_ids: List, days: int) -> Dict`
    - [ ] 多线条图数据
    - [ ] 图例配置
  - [ ] 实现 `prepare_distribution_chart_data(entity_type: str, date: date) -> Dict`
    - [ ] 饼图数据（等级分布）
    - [ ] 柱状图数据
  - [ ] 实现 `prepare_heatmap_data(sector_id: int, date: date) -> Dict`
    - [ ] 板块内股票强度热力图数据
    - [ ] 颜色映射

### 7. 趋势预警功能 (AC: 7)

- [ ] 创建 `server/src/services/strength_alert_service.py`
  - [ ] 实现 `detect_sudden_change(current_score, history_scores, threshold=20) -> Dict`
    - [ ] 检测强度突变
    - [ ] 单日大幅变化
    - [ ] 返回预警级别
  - [ ] 实现 `check_grade_upgrade(history: List) -> Optional[Dict]`
    - [ ] 检测等级升级
    - [ ] 连续性判断
  - [ ] 实现 `check_grade_downgrade(history: List) -> Optional[Dict]`
    - [ ] 检测等级降级
  - [ ] 实现 `generate_alerts(entity_id: int, db: Session) -> List[Dict]`
    - [ ] 综合预警检测
    - [ ] 预警优先级
    - [ ] 预警消息模板
  - [ ] 预警级别定义：
    ```python
    ALERT_LEVELS = {
        "critical": "紧急",  # 强度暴跌 > 30%
        "warning": "警告",   # 强度变化 > 20%
        "info": "提醒",      # 等级变化
        "normal": "正常"
    }
    ```

### 8. API 集成 (AC: 8)

- [ ] 创建 `server/src/api/v1/endpoints/trend_analysis.py`
  - [ ] 实现 `GET /api/v1/stocks/{stock_id}/trend` 接口
    - [ ] 返回趋势分析结果
  - [ ] 实现 `GET /api/v1/stocks/{stock_id}/turning-points` 接口
    - [ ] 返回转折点列表
  - [ ] 实现 `GET /api/v1/stocks/{stock_id}/stats` 接口
    - [ ] 返回统计信息
  - [ ] 实现 `POST /api/v1/compare` 接口
    - [ ] 对比分析接口
  - [ ] 实现 `GET /api/v1/stocks/{stock_id}/chart-data` 接口
    - [ ] 可视化数据接口
  - [ ] 实现 `GET /api/v1/stocks/{stock_id}/alerts` 接口
    - [ ] 预警信息接口

### 9. 测试 (AC: 8)

- [ ] 创建 `server/tests/services/test_trend_analysis_service.py`
  - [ ] 测试趋势识别准确性
  - [ ] 测试边界条件
  - [ ] 测试数据不足情况
- [ ] 创建 `server/tests/services/test_turning_point_service.py`
  - [ ] 测试峰值检测
  - [ ] 测试波谷检测
  - [ ] 测试突破检测
- [ ] 创建 `server/tests/services/test_comparison_service.py`
  - [ ] 测试对比分析
  - [ ] 测试相关性计算
- [ ] 创建 `server/tests/services/test_alert_service.py`
  - [ ] 测试预警检测
  - [ ] 测试预警级别判断
- [ ] 集成测试
  - [ ] 完整分析流程测试
  - [ ] 性能测试

## Dev Notes

### 故事依赖关系

**前置依赖**:
- Story 10.1: 数据库表结构优化（使用优化后的表）
- Story 10.2: 均线系统强度计算引擎（使用计算服务）
- Story 10.3: 强度数据服务（使用历史数据服务）
- Story 10.4: 强度 API 接口（使用 API 层）

**被以下故事依赖**:
- 前端可视化开发（使用趋势分析数据）

### 服务架构

```
┌─────────────────────────────────────────────────┐
│              Trend Analysis Layer               │
│  ┌──────────────────────────────────────────┐  │
│  │ TrendAnalysisService                     │  │
│  │ - identify_trend()                       │  │
│  │ - calculate_moving_avg_trend()           │  │
│  │ - detect_consolidation()                 │  │
│  └──────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────┐  │
│  │ TurningPointService                      │  │
│  │ - find_peaks()                           │  │
│  │ - find_valleys()                         │  │
│  │ - detect_breakthrough()                  │  │
│  │ - find_inflection_points()               │  │
│  └──────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────┐  │
│  │ StatisticsService                        │  │
│  │ - calculate_basic_stats()                │  │
│  │ - calculate_grade_distribution()         │  │
│  │ - calculate_volatility()                 │  │
│  └──────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────┐  │
│  │ ComparisonService                        │  │
│  │ - compare_stocks()                       │  │
│  │ - compare_sectors()                      │  │
│  │ - calculate_correlation()                │  │
│  └──────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────┐  │
│  │ AlertService                             │  │
│  │ - detect_sudden_change()                 │  │
│  │ - check_grade_upgrade()                  │  │
│  │ - generate_alerts()                      │  │
│  └──────────────────────────────────────────┘  │
└────────────────┬────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────┐
│         Strength History Data (Story 10.3)      │
└─────────────────────────────────────────────────┘
```

### 趋势识别算法

```python
def identify_trend(history_data: List[StrengthScore]) -> Dict:
    """
    识别趋势特征

    Args:
        history_data: 历史强度数据列表

    Returns:
        趋势分析结果
    """
    if len(history_data) < 3:
        return {"trend_type": "unknown", "confidence": 0}

    # 提取分数和日期
    scores = [float(d.score) for d in history_data]
    dates = [d.date for d in history_data]

    # 1. 计算线性回归斜率
    x = np.arange(len(scores))
    z = np.polyfit(x, scores, 1)
    slope = z[0]

    # 2. 计算R²确定拟合优度
    p = np.poly1d(z)
    y_hat = p(x)
    y_bar = np.mean(scores)
    ss_tot = np.sum((scores - y_bar) ** 2)
    ss_res = np.sum((scores - y_hat) ** 2)
    r_squared = 1 - (ss_res / ss_tot)

    # 3. 计算趋势强度（斜率的绝对值）
    trend_strength = abs(slope)

    # 4. 判断趋势类型
    if slope > 0.5:
        trend_type = "strong_up"
        direction = "强势上涨"
    elif slope > 0.1:
        trend_type = "up"
        direction = "上涨"
    elif slope > -0.1:
        trend_type = "neutral"
        direction = "震荡"
    elif slope > -0.5:
        trend_type = "down"
        direction = "下跌"
    else:
        trend_type = "strong_down"
        direction = "强势下跌"

    # 5. 检测横盘整理
    is_consolidating = detect_consolidation(scores)

    # 6. 计算移动平均线趋势
    ma5_trend = calculate_ma_trend(scores, 5)
    ma10_trend = calculate_ma_trend(scores, 10)
    ma20_trend = calculate_ma_trend(scores, 20)

    return {
        "trend_type": trend_type,
        "trend_direction": direction,
        "trend_strength": round(trend_strength, 4),
        "slope": round(slope, 4),
        "r_squared": round(r_squared, 4),
        "confidence": "high" if r_squared > 0.7 else "medium" if r_squared > 0.4 else "low",
        "is_consolidating": is_consolidating,
        "ma_trends": {
            "ma5": ma5_trend,
            "ma10": ma10_trend,
            "ma20": ma20_trend
        },
        "start_date": dates[0].isoformat(),
        "end_date": dates[-1].isoformat(),
        "data_points": len(scores)
    }


def detect_consolidation(scores: List[float], threshold: float = 2.0) -> Dict:
    """
    检测横盘整理

    Args:
        scores: 分数列表
        threshold: 波动阈值

    Returns:
        整理状态信息
    """
    if len(scores) < 5:
        return {"is_consolidating": False, "reason": "数据不足"}

    # 计算标准差
    std_dev = np.std(scores)

    # 计算价格范围
    price_range = max(scores) - min(scores)

    # 判断是否为横盘
    is_consolidating = std_dev < threshold and price_range < threshold * 3

    return {
        "is_consolidating": is_consolidating,
        "std_dev": round(std_dev, 2),
        "price_range": round(price_range, 2),
        "support_level": round(min(scores), 2),
        "resistance_level": round(max(scores), 2)
    }
```

### 转折点检测算法

```python
from scipy.signal import find_peaks
import numpy as np


def find_turning_points(scores: List[float], dates: List[date],
                        prominence: float = 3.0) -> Dict:
    """
    查找转折点（波峰和波谷）

    Args:
        scores: 分数列表
        dates: 日期列表
        prominence: 峰值显著性的最小值

    Returns:
        转折点信息
    """
    scores_array = np.array(scores)

    # 查找波峰
    peaks, peak_properties = find_peaks(scores_array, prominence=prominence)

    # 查找波谷（反转数组后查找波峰）
    valleys, valley_properties = find_peaks(-scores_array, prominence=prominence)

    # 构建波峰信息
    peak_info = []
    for idx in peaks:
        peak_info.append({
            "date": dates[idx].isoformat(),
            "value": round(float(scores[idx]), 2),
            "type": "peak",
            "prominence": round(float(peak_properties['prominences'][
                list(peaks).index(idx)]), 2)
        })

    # 构建波谷信息
    valley_info = []
    for idx in valleys:
        valley_info.append({
            "date": dates[idx].isoformat(),
            "value": round(float(scores[idx]), 2),
            "type": "valley",
            "prominence": round(float(valley_properties['prominences'][
                list(valleys).index(idx)]), 2)
        })

    # 合并所有转折点并按日期排序
    all_points = sorted(peak_info + valley_info,
                       key=lambda x: x['date'])

    return {
        "turning_points": all_points,
        "peak_count": len(peak_info),
        "valley_count": len(valley_info),
        "total_count": len(all_points)
    }


def detect_breakthrough(current_score: float,
                        history_scores: List[float],
                        threshold: float = 70.0) -> Dict:
    """
    检测突破

    Args:
        current_score: 当前分数
        history_scores: 历史分数列表
        threshold: 突破阈值

    Returns:
        突破信息
    """
    if len(history_scores) < 5:
        return {"has_breakthrough": False, "reason": "数据不足"}

    previous_avg = np.mean(history_scores[-5:])
    change = current_score - previous_avg
    change_pct = (change / previous_avg) * 100 if previous_avg > 0 else 0

    # 检测向上突破
    if current_score > threshold and previous_avg < threshold:
        return {
            "has_breakthrough": True,
            "breakthrough_type": "upward",
            "threshold": threshold,
            "previous_avg": round(previous_avg, 2),
            "current_value": round(current_score, 2),
            "change": round(change, 2),
            "change_pct": round(change_pct, 2),
            "strength": "strong" if change_pct > 10 else "moderate"
        }

    # 检测向下突破
    if current_score < threshold and previous_avg > threshold:
        return {
            "has_breakthrough": True,
            "breakthrough_type": "downward",
            "threshold": threshold,
            "previous_avg": round(previous_avg, 2),
            "current_value": round(current_score, 2),
            "change": round(change, 2),
            "change_pct": round(change_pct, 2),
            "strength": "strong" if change_pct < -10 else "moderate"
        }

    return {"has_breakthrough": False}
```

### 统计分析实现

```python
def calculate_comprehensive_stats(history_data: List[StrengthScore]) -> Dict:
    """
    计算综合统计信息

    Args:
        history_data: 历史强度数据

    Returns:
        统计信息
    """
    scores = [float(d.score) for d in history_data]
    dates = [d.date for d in history_data]

    # 基础统计
    basic_stats = {
        "max": {
            "value": round(max(scores), 2),
            "date": dates[scores.index(max(scores))].isoformat()
        },
        "min": {
            "value": round(min(scores), 2),
            "date": dates[scores.index(min(scores))].isoformat()
        },
        "mean": round(np.mean(scores), 2),
        "median": round(np.median(scores), 2),
        "std_dev": round(np.std(scores), 2),
        "variance": round(np.var(scores), 2),
        "coefficient_of_variation": round(np.std(scores) / np.mean(scores) * 100, 2)
            if np.mean(scores) > 0 else 0
    }

    # 等级分布
    grades = [d.strength_grade for d in history_data if d.strength_grade]
    grade_counts = {}
    for grade in grades:
        grade_counts[grade] = grade_counts.get(grade, 0) + 1

    grade_distribution = []
    for grade in ["S+", "S", "A+", "A", "B+", "B", "C+", "C", "D+", "D"]:
        if grade in grade_counts:
            grade_distribution.append({
                "grade": grade,
                "count": grade_counts[grade],
                "percentage": round(grade_counts[grade] / len(grades) * 100, 2)
            })

    # 涨跌统计
    up_days = sum(1 for i in range(1, len(scores)) if scores[i] > scores[i-1])
    down_days = sum(1 for i in range(1, len(scores)) if scores[i] < scores[i-1])
    flat_days = len(scores) - 1 - up_days - down_days

    # 波动率（使用标准差）
    volatility = basic_stats["std_dev"]

    # 动量指标
    momentum_5d = (scores[-1] - scores[-6]) / scores[-6] * 100 if len(scores) >= 6 else 0
    momentum_10d = (scores[-1] - scores[-11]) / scores[-11] * 100 if len(scores) >= 11 else 0
    momentum_20d = (scores[-1] - scores[-21]) / scores[-21] * 100 if len(scores) >= 21 else 0

    return {
        "period": {
            "start_date": dates[0].isoformat(),
            "end_date": dates[-1].isoformat(),
            "data_points": len(scores)
        },
        "basic_stats": basic_stats,
        "grade_distribution": grade_distribution,
        "price_change_stats": {
            "up_days": up_days,
            "down_days": down_days,
            "flat_days": flat_days,
            "up_ratio": round(up_days / (len(scores) - 1) * 100, 2) if len(scores) > 1 else 0
        },
        "volatility": round(volatility, 2),
        "momentum": {
            "5d": round(momentum_5d, 2),
            "10d": round(momentum_10d, 2),
            "20d": round(momentum_20d, 2)
        }
    }
```

### 对比分析实现

```python
def compare_entities(entity_ids: List[int],
                     entity_type: str,
                     days: int,
                     db: Session) -> Dict:
    """
    对比多个实体的强度表现

    Args:
        entity_ids: 实体ID列表
        entity_type: 实体类型（'stock' 或 'sector'）
        days: 查询天数
        db: 数据库会话

    Returns:
        对比分析结果
    """
    if len(entity_ids) > 10:
        raise ValueError("最多支持10个实体对比")

    # 获取所有实体的历史数据
    all_data = {}
    for entity_id in entity_ids:
        history = get_stock_history(entity_id, days, db)
        all_data[entity_id] = history

    # 准备对比数据
    comparison_data = []
    for entity_id, history in all_data.items():
        if not history:
            continue

        scores = [float(d.score) for d in history]
        latest_score = scores[-1]
        start_score = scores[0]
        total_change = latest_score - start_score
        total_change_pct = (total_change / start_score * 100) if start_score > 0 else 0

        comparison_data.append({
            "entity_id": entity_id,
            "symbol": history[0].symbol if history else None,
            "name": history[0].stock_name if entity_type == 'stock' else history[0].sector_name,
            "latest_score": round(latest_score, 2),
            "start_score": round(start_score, 2),
            "total_change": round(total_change, 2),
            "total_change_pct": round(total_change_pct, 2),
            "avg_score": round(np.mean(scores), 2),
            "max_score": round(max(scores), 2),
            "min_score": round(min(scores), 2),
            "volatility": round(np.std(scores), 2),
            "rank_in_comparison": None  # 稍后填充
        })

    # 按涨跌幅排序
    comparison_data.sort(key=lambda x: x['total_change_pct'], reverse=True)

    # 填充排名
    for rank, item in enumerate(comparison_data, start=1):
        item['rank_in_comparison'] = rank

    # 计算相关性矩阵
    correlation_matrix = calculate_correlation_matrix(all_data)

    return {
        "entity_type": entity_type,
        "comparison_period": f"最近{days}天",
        "entities_count": len(comparison_data),
        "comparison_data": comparison_data,
        "correlation_matrix": correlation_matrix,
        "best_performer": comparison_data[0] if comparison_data else None,
        "worst_performer": comparison_data[-1] if comparison_data else None
    }


def calculate_correlation_matrix(all_data: Dict[int, List[StrengthScore]]) -> List[List[float]]:
    """
    计算相关性矩阵

    Args:
        all_data: 实体ID到历史数据的映射

    Returns:
        相关性矩阵
    """
    entity_ids = list(all_data.keys())
    n = len(entity_ids)

    # 提取各实体的分数序列
    scores_dict = {}
    min_length = float('inf')

    for entity_id in entity_ids:
        scores = [float(d.score) for d in all_data[entity_id]]
        scores_dict[entity_id] = scores
        min_length = min(min_length, len(scores))

    # 统一长度（取最短）
    for entity_id in entity_ids:
        scores_dict[entity_id] = scores_dict[entity_id][-min_length:]

    # 计算相关性矩阵
    correlation_matrix = [[0.0] * n for _ in range(n)]

    for i in range(n):
        for j in range(n):
            if i == j:
                correlation_matrix[i][j] = 1.0
            else:
                corr = np.corrcoef(scores_dict[entity_ids[i]],
                                  scores_dict[entity_ids[j]])[0, 1]
                correlation_matrix[i][j] = round(float(corr), 4) if not np.isnan(corr) else 0.0

    return {
        "entity_ids": entity_ids,
        "matrix": correlation_matrix
    }
```

### 预警检测实现

```python
def generate_strength_alerts(entity_id: int,
                            entity_type: str,
                            db: Session) -> List[Dict]:
    """
    生成强度预警

    Args:
        entity_id: 实体ID
        entity_type: 实体类型
        db: 数据库会话

    Returns:
        预警列表
    """
    alerts = []

    # 获取最近30天数据
    history = get_stock_history(entity_id, 30, db)

    if len(history) < 5:
        return alerts

    current = history[-1]
    scores = [float(d.score) for d in history]

    # 1. 检测强度突变
    if len(scores) >= 2:
        change = scores[-1] - scores[-2]
        change_pct = (change / scores[-2] * 100) if scores[-2] > 0 else 0

        if abs(change_pct) > 30:
            alerts.append({
                "level": "critical",
                "type": "sudden_change",
                "message": f"强度{'暴升' if change > 0 else '暴跌'}",
                "detail": f"单日变化{change_pct:.2f}%",
                "current_value": round(scores[-1], 2),
                "previous_value": round(scores[-2], 2),
                "timestamp": current.date.isoformat()
            })
        elif abs(change_pct) > 20:
            alerts.append({
                "level": "warning",
                "type": "sudden_change",
                "message": f"强度{'大幅上升' if change > 0 else '大幅下降'}",
                "detail": f"单日变化{change_pct:.2f}%",
                "current_value": round(scores[-1], 2),
                "previous_value": round(scores[-2], 2),
                "timestamp": current.date.isoformat()
            })

    # 2. 检测等级变化
    if len(history) >= 2:
        current_grade = current.strength_grade
        previous_grade = history[-2].strength_grade

        if current_grade != previous_grade:
            grade_order = ["S+", "S", "A+", "A", "B+", "B", "C+", "C", "D+", "D"]

            if grade_order.index(current_grade) < grade_order.index(previous_grade):
                alerts.append({
                    "level": "info",
                    "type": "grade_upgrade",
                    "message": f"强度等级从 {previous_grade} 升级至 {current_grade}",
                    "from_grade": previous_grade,
                    "to_grade": current_grade,
                    "timestamp": current.date.isoformat()
                })
            else:
                alerts.append({
                    "level": "warning",
                    "type": "grade_downgrade",
                    "message": f"强度等级从 {previous_grade} 降级至 {current_grade}",
                    "from_grade": previous_grade,
                    "to_grade": current_grade,
                    "timestamp": current.date.isoformat()
                })

    # 3. 检测突破
    breakthrough = detect_breakthrough(scores[-1], scores[:-1], threshold=70)
    if breakthrough.get("has_breakthrough"):
        alerts.append({
            "level": "info",
            "type": "breakthrough",
            "message": f"强度{'向上' if breakthrough['breakthrough_type'] == 'upward' else '向下'}突破70分",
            "detail": breakthrough,
            "timestamp": current.date.isoformat()
        })

    # 4. 检测趋势变化
    trend = identify_trend(history)
    if trend["trend_type"] in ["strong_down", "strong_up"]:
        alerts.append({
            "level": "warning",
            "type": "trend_change",
            "message": f"检测到{trend['trend_direction']}趋势",
            "detail": f"趋势强度: {trend['trend_strength']}",
            "timestamp": current.date.isoformat()
        })

    return alerts
```

### 定时任务配置

```python
# server/src/tasks/snapshot_tasks.py

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from datetime import time
from server.src.services.strength_snapshot_service import StrengthSnapshotService

scheduler = AsyncIOScheduler()

async def daily_snapshot_task():
    """每日收盘后创建强度快照"""
    snapshot_service = StrengthSnapshotService()
    await snapshot_service.create_daily_snapshot(date.today())


# 配置每日任务（假设收盘时间为15:00）
scheduler.add_job(
    daily_snapshot_task,
    trigger='cron',
    hour=15,
    minute=30,
    id='daily_strength_snapshot',
    replace_existing=True
)
```

### 可视化数据格式

```python
def prepare_chart_data(entity_id: int,
                      entity_type: str,
                      days: int,
                      db: Session) -> Dict:
    """
    准备 ECharts 图表数据

    Returns:
        ECharts 格式的图表数据
    """
    history = get_stock_history(entity_id, days, db)

    # 提取数据
    dates = [d.date.isoformat() for d in history]
    scores = [float(d.score) for d in history]
    price_scores = [float(d.price_position_score) for d in history if d.price_position_score]
    alignment_scores = [float(d.ma_alignment_score) for d in history if d.ma_alignment_score]

    return {
        "title": {"text": f"{history[0].symbol if history else ''} 强度趋势图"},
        "tooltip": {"trigger": "axis"},
        "legend": {"data": ["综合强度", "价格位置", "均线排列"]},
        "xAxis": {
            "type": "category",
            "data": dates
        },
        "yAxis": {
            "type": "value",
            "name": "强度得分",
            "min": 0,
            "max": 100
        },
        "series": [
            {
                "name": "综合强度",
                "type": "line",
                "data": scores,
                "smooth": True,
                "lineStyle": {"width": 3},
                "itemStyle": {"color": "#5470c6"}
            },
            {
                "name": "价格位置",
                "type": "line",
                "data": price_scores,
                "smooth": True,
                "lineStyle": {"width": 2, "type": "dashed"},
                "itemStyle": {"color": "#91cc75"}
            },
            {
                "name": "均线排列",
                "type": "line",
                "data": alignment_scores,
                "smooth": True,
                "lineStyle": {"width": 2, "type": "dashed"},
                "itemStyle": {"color": "#fac858"}
            }
        ]
    }
```

### 源树组件需要修改

```
server/
├── src/
│   └── services/
│       ├── strength_snapshot_service.py         # 新建：快照服务
│       ├── trend_analysis_service.py           # 新建：趋势分析
│       ├── turning_point_service.py            # 新建：转折点检测
│       ├── strength_statistics_service.py      # 新建：统计分析
│       ├── comparison_service.py               # 新建：对比分析
│       ├── visualization_data_service.py       # 新建：可视化数据
│       └── strength_alert_service.py           # 新建：预警服务
├── src/
│   └── api/
│       └── v1/
│           └── endpoints/
│               └── trend_analysis.py           # 新建：趋势分析 API
├── src/
│   └── tasks/
│       └── snapshot_tasks.py                   # 新建：定时任务
└── tests/
    └── services/
        ├── test_trend_analysis_service.py      # 新建
        ├── test_turning_point_service.py       # 新建
        ├── test_comparison_service.py          # 新建
        └── test_alert_service.py               # 新建
```

### 性能要求

| 操作 | 性能要求 |
|------|---------|
| 趋势分析（30天） | < 100ms |
| 转折点检测（365天） | < 200ms |
| 对比分析（5个实体） | < 500ms |
| 相关性计算（10个实体） | < 1s |
| 预警检测 | < 50ms |
| 可视化数据准备 | < 150ms |

### 测试标准摘要

**单元测试要求**:
1. 趋势识别算法准确性测试
2. 转折点检测准确性测试
3. 统计计算正确性测试
4. 相关性计算测试
5. 预警检测测试

**集成测试要求**:
1. 完整分析流程测试
2. 与数据库集成测试
3. 性能测试
4. 边界条件测试

## Dev Agent Record

### Context Reference

<!-- Path(s) to story context XML will be added here by context workflow -->

### Agent Model Used

glm-4.7

### Completion Notes

**实现进行中** (2025-12-28)

**Task 1: 历史数据存储** - ✅ 已完成
- 创建 `server/src/services/strength_snapshot_service.py`
- 实现 `create_daily_snapshot()` - 遍历所有股票和板块计算强度
- 实现 `batch_create_snapshots()` - 批量创建多日快照
- 实现 `_update_ranks_and_percentiles()` - 更新排名和百分位
- 实现 `get_snapshot_status()` - 获取快照状态
- 创建测试 `server/tests/services/test_strength_snapshot_service.py`

**Task 2: 趋势特征识别** - ✅ 已完成
- 创建 `server/src/services/trend_analysis_service.py`
- 实现 `identify_trend()` - 线性回归斜率计算，R²拟合优度
- 实现 `_detect_consolidation()` - 横盘整理检测
- 实现 `_calculate_ma_trend()` - 移动平均线趋势计算
- 实现 `detect_consolidation()` - 异步横盘检测
- 实现 `calculate_moving_avg_trend()` - 异步MA趋势
- 实现 `get_trend_summary()` - 趋势摘要
- 创建测试 `server/tests/services/test_trend_analysis_service.py`
- 所有21个单元测试通过

**剩余任务**:
- Task 3: 关键转折点检测
- Task 4: 统计功能
- Task 5: 对比分析功能
- Task 6: 可视化数据准备
- Task 7: 趋势预警功能
- Task 8: API 集成
- Task 9: 完整测试

**修复的问题**:
- 修复 Pydantic V2 兼容性问题（strength.py schema）
- 添加 V1/V2 兼容类型定义

**代码审查修复** (2025-12-28):
- 更新 AC 复选框状态（只有 AC 1-2 完成）
- 更新 Task 复选框状态（Task 1-2 主要子任务完成）
- 删除冗余 import（strength_snapshot_service.py）

### File List

**新建文件**:
- `server/src/services/strength_snapshot_service.py` - 快照服务
- `server/src/services/trend_analysis_service.py` - 趋势分析服务
- `server/tests/services/test_strength_snapshot_service.py` - 快照服务测试（13个测试）
- `server/tests/services/test_trend_analysis_service.py` - 趋势分析测试（21个测试）

**修改文件**:
- `server/src/api/schemas/strength.py` - 添加 V2 schema 和 V1/V2 兼容类型
- `server/src/api/schemas/__init__.py` - 更新导出
