# Story 10.2: 均线系统强度计算引擎

Status: done

## Story

作为一名 系统开发者，
我需要 实现基于均线系统的两维度强度计算引擎（价格位置 + 均线排列），
以便 为个股和板块提供更准确、更简洁的强度评分。

## Acceptance Criteria

1. ✅ 实现价格位置得分计算（基于8条均线）
2. ✅ 实现均线排列得分计算（多头/空头排列检测）
3. ✅ 实现综合强度得分计算：(价格位置 + 均线排列) / 2
4. ✅ 实现短中长期强度分类
5. ✅ 实现强度等级划分（10级：S+/S/A+/A/B+/B/C+/C/D+/D）
6. ✅ 支持从 `moving_average_data` 表读取均线数据
7. ✅ 支持个股和板块两种实体类型
8. ✅ 添加完整的单元测试
9. ✅ 处理数据不足情况（如新股历史数据不足240天）

## Tasks / Subtasks

### 1. 价格位置得分计算器 (AC: 1)

- [x] 创建 `server/src/services/calculation/ma_system/price_position_scorer.py`
  - [x] 实现 `calculate_score(ratio: float) -> float` 函数
  - [x] 评分标准：
    ```
    ratio > +5%:  100分
    ratio > +3%:  90-100分
    ratio > +1%:  75-90分
    ratio > +0.5%: 60-75分
    ratio ∈ [-0.5%, +0.5%]: 50分
    ratio < -0.5%: 40分
    ratio < -1%:  25分
    ratio < -3%:  10分
    ratio < -5%:  0分
    ```
  - [x] 实现 `calculate_weighted_score(price, ma_values) -> float`
  - [x] 均线权重配置：
    ```python
    MA_WEIGHTS = {
        5: 0.15,   # MA5
        10: 0.15,  # MA10
        20: 0.18,  # MA20
        30: 0.15,  # MA30
        60: 0.15,  # MA60
        90: 0.10,  # MA90
        120: 0.07, # MA120
        240: 0.05  # MA240
    }
    ```

### 2. 均线排列评分器 (AC: 2)

- [x] 创建 `server/src/services/calculation/ma_system/ma_alignment_scorer.py`
  - [x] 实现 `calculate_score(price, ma_values) -> Dict` 函数
  - [x] 检测8个关系：
    - [x] 价格 > MA5
    - [x] MA5 > MA10
    - [x] MA10 > MA20
    - [x] MA20 > MA30
    - [x] MA30 > MA60
    - [x] MA60 > MA90
    - [x] MA90 > MA120
    - [x] MA120 > MA240
  - [x] 评分标准：
    ```
    8/8 符合 → 100分, 状态 = "perfect_bull"
    6-7/8 符合 → 80-90分, 状态 = "strong_bull"
    4-5/8 符合 → 60-70分, 状态 = "bull"
    3-4/8 符合 → 40-50分, 状态 = "neutral"
    1-2/8 符合 → 10-30分, 状态 = "bear"
    0/8 符合 → 0分, 状态 = "perfect_bear"
    ```

### 3. 综合强度计算器 (AC: 3, 4, 5)

- [x] 创建 `server/src/services/calculation/ma_system/strength_calculator_v2.py`
  - [x] 实现 `calculate_composite_strength(price, ma_values) -> Dict`
  - [x] 综合公式：`composite = (price_position_score + ma_alignment_score) / 2`
  - [x] 实现短中长期强度计算：
    ```python
    短期强度 = 基于 MA5/10/20 的加权平均
    中期强度 = 基于 MA30/60 的加权平均
    长期强度 = 基于 MA90/120/240 的加权平均
    ```
  - [x] 实现强度等级判定（使用 `get_strength_grade()` 函数）
  - [x] 实现价格相对均线位置计算（8个位置）

### 4. 数据加载器 (AC: 6)

- [x] 创建 `server/src/services/calculation/ma_system/ma_data_loader.py`
  - [x] 实现 `load_ma_values(symbol: str, date: date) -> Dict[int, float]`
  - [x] 从 `moving_average_data` 表读取8条均线数据
  - [x] 处理缺失的周期（返回可用均线）
  - [x] 从 `daily_market_data` 表读取当前价格
  - [x] 数据缓存优化

### 5. 主计算服务 (AC: 7, 8)

- [x] 创建 `server/src/services/strength_service_v2.py`
  - [x] 实现 `calculate_stock_strength(stock_id, date) -> Dict`
  - [x] 实现 `calculate_sector_strength(sector_id, date) -> Dict`
  - [x] 实现 `batch_calculate(entity_ids, date) -> Dict`
  - [x] 结果保存到 `strength_scores` 表（period='all'）

### 6. 数据不足处理 (AC: 9)

- [x] 实现渐近式计算：
  - [x] 检查可用数据天数
  - [x] 根据可用数据筛选可计算周期
  - [x] 至少需要5天数据（计算MA5）
  - [x] 数据不足时返回 None 和警告信息

### 7. 测试 (AC: 8)

- [x] 创建 `server/tests/test_ma_system_calculator.py`
  - [x] 测试价格位置得分计算
  - [x] 测试均线排列得分计算
  - [x] 测试综合强度计算
  - [x] 测试短中长期强度分类
  - [x] 测试强度等级判定
  - [x] 测试边界条件
  - [x] 测试数据不足处理
  - [x] 性能测试（单只股票 < 100ms）

## Dev Notes

### 故事依赖关系

**前置依赖**:
- Story 10.1: 数据库表结构优化（状态: Ready for Review）
  - ✅ 数据库迁移已完成，所有新字段已添加到 `strength_scores` 表
  - ✅ `get_strength_grade()` 函数已在 `server/src/config/calculation.py` 中定义
  - ✅ 迁移文件路径: `server/alembic/versions/2025_12_28_2126-d1a36df87bdc_optimize_strength_scores_table_for_ma_.py`
- Epic 3: 数据采集和处理引擎（提供基础数据表）
  - `moving_average_data` 表存储8条均线数据
  - `daily_market_data` 表存储日线行情数据

**被以下故事依赖**:
- Story 10.3: 强度数据服务（使用计算引擎）
- Story 10.4: 强度 API 接口（提供数据）

### 算法详细定义

#### 1. 价格位置得分

```python
def price_position_score(ratio: float) -> float:
    """根据价格位置比率计算得分"""
    if ratio > 5:
        return 100
    elif ratio > 3:
        return 90 + (ratio - 3) * 5  # 90-100
    elif ratio > 1:
        return 75 + (ratio - 1) * 7.5  # 75-90
    elif ratio > 0.5:
        return 60 + (ratio - 0.5) * 30  # 60-75
    elif ratio > -0.5:
        return 50
    elif ratio > -1:
        return 40 + (ratio + 1) * 20  # 40-50
    elif ratio > -3:
        return 25 + (ratio + 3) * 7.5  # 25-40
    elif ratio > -5:
        return 10 + (ratio + 5) * 7.5  # 10-25
    else:
        return max(0, (ratio + 5) * 2)  # 0-10
```

#### 2. 均线排列得分

```python
def calculate_ma_alignment_score(price: float, ma_values: Dict[int, float]) -> Dict:
    """计算均线排列得分"""
    checks = []
    periods = [5, 10, 20, 30, 60, 90, 120, 240]

    # 价格 > MA5
    if 5 in ma_values:
        checks.append(1 if price > ma_values[5] else 0)

    # MA5 > MA10 > ... > MA240
    for i in range(len(periods) - 1):
        short, long = periods[i], periods[i + 1]
        if short in ma_values and long in ma_values:
            checks.append(1 if ma_values[short] > ma_values[long] else 0)

    bull_count = sum(checks)
    total = len(checks)

    if bull_count == total:
        return 100, "perfect_bull"
    elif bull_count >= total * 0.75:
        return 80 + (bull_count - total * 0.75) * 10, "strong_bull"
    elif bull_count >= total * 0.5:
        return 60 + (bull_count - total * 0.5) * 10, "bull"
    elif bull_count >= total * 0.25:
        return 40 + (bull_count - total * 0.25) * 10, "neutral"
    else:
        return bull_count * 10, "bear"
```

#### 3. 综合强度计算

```python
def calculate_composite_strength(price: float, ma_values: Dict[int, float]) -> Dict:
    """计算综合强度"""
    # 1. 价格位置得分
    price_score = calculate_price_position_score_weighted(price, ma_values)

    # 2. 均线排列得分
    alignment_score, alignment_state = calculate_ma_alignment_score(price, ma_values)

    # 3. 综合得分
    composite = (price_score + alignment_score) / 2

    # 4. 短中长期强度
    short_term = calculate_term_score(price, ma_values, [5, 10, 20])
    medium_term = calculate_term_score(price, ma_values, [30, 60])
    long_term = calculate_term_score(price, ma_values, [90, 120, 240])

    # 5. 强度等级
    grade = get_strength_grade(composite)

    # 6. 价格相对均线位置
    price_positions = {}
    for period in [5, 10, 20, 30, 60, 90, 120, 240]:
        if period in ma_values:
            price_positions[f"above_ma{period}"] = (
                (price - ma_values[period]) / ma_values[period] * 100
            )

    return {
        'composite_score': round(composite, 2),
        'price_position_score': round(price_score, 2),
        'ma_alignment_score': round(alignment_score, 2),
        'ma_alignment_state': alignment_state,
        'short_term_score': round(short_term, 2),
        'medium_term_score': round(medium_term, 2),
        'long_term_score': round(long_term, 2),
        'strength_grade': grade,
        'price_positions': price_positions,
        'ma_values': ma_values
    }
```

#### 4. 强度等级判定

```python
STRENGTH_GRADES = {
    "S+": (90, 100),
    "S": (85, 89),
    "A+": (75, 84),
    "A": (65, 74),
    "B+": (55, 64),
    "B": (45, 54),
    "C+": (35, 44),
    "C": (25, 34),
    "D+": (15, 24),
    "D": (0, 14)
}

def get_strength_grade(score: float) -> str:
    """根据得分获取强度等级"""
    for grade, (min_score, max_score) in STRENGTH_GRADES.items():
        if min_score <= score <= max_score:
            return grade
    return "D"
```

### 源树组件需要修改

```
server/
├── src/
│   ├── services/
│   │   └── calculation/
│   │       └── ma_system/                    # 新建目录
│   │           ├── __init__.py
│   │           ├── price_position_scorer.py   # 新建
│   │           ├── ma_alignment_scorer.py     # 新建
│   │           ├── strength_calculator_v2.py   # 新建
│   │           └── ma_data_loader.py          # 新建
│   └── services/
│       └── strength_service_v2.py             # 新建
├── tests/
│   └── test_ma_system_calculator.py           # 新建
└── config/
    └── ma_system.py                            # 新建：均线系统配置
```

### 性能要求

- 单只股票计算: < 100ms
- 100只股票批量计算: < 10s
- 1000只股票批量计算: < 5min

### 与旧系统对比

| 特性 | 旧系统 | 新系统 |
|------|--------|--------|
| 计算维度 | 多指标（均线、成交量、动量等） | 两维度（价格位置 + 均线排列） |
| 均线周期 | 5条 | 8条 |
| 复杂度 | 高 | 低 |
| 可解释性 | 中 | 高 |
| 准确性 | 待验证 | 待验证 |

### 测试标准摘要

**单元测试要求**:
1. 价格位置得分边界测试
2. 均线排列得分各种情况测试
3. 综合强度计算正确性测试
4. 数据不足处理测试

**集成测试要求**:
1. 完整计算流程测试
2. 与现有数据表集成测试
3. 批量计算性能测试

### 常量配置

在 `server/src/config/ma_system.py` 中定义：

```python
# 均线周期配置
MA_PERIODS = [5, 10, 20, 30, 60, 90, 120, 240]

# 均线权重配置
MA_WEIGHTS = {
    5: 0.15, 10: 0.15, 20: 0.18, 30: 0.15,
    60: 0.15, 90: 0.10, 120: 0.07, 240: 0.05
}

# 短中长期分组
TERM_GROUPS = {
    'short': [5, 10, 20],
    'medium': [30, 60],
    'long': [90, 120, 240]
}

# 强度等级定义
STRENGTH_GRADES = {
    "S+": (90, 100, "极强"),
    "S": (85, 89, "很强"),
    "A+": (75, 84, "强"),
    "A": (65, 74, "偏强"),
    "B+": (55, 64, "中性偏强"),
    "B": (45, 54, "中性"),
    "C+": (35, 44, "中性偏弱"),
    "C": (25, 34, "偏弱"),
    "D+": (15, 24, "弱"),
    "D": (0, 14, "很弱"),
}
```

### 架构和编码模式（从现有代码库学习）

**参考现有服务模式** (`server/src/services/stock_ma_service.py`):
- 使用 AsyncSession 进行数据库操作
- 批量操作时使用 batch_size 控制内存（推荐 500）
- 实现进度回调用于长时间操作
- 使用 logger 记录关键操作和错误

**参考现有计算器模式** (`server/src/services/calculation/strength_calculator.py`):
- 继承 `BaseCalculator` 基类
- 使用 `CalculationResult` 返回结果
- 实现输入验证 `validate_input()`
- 处理渐近式计算（数据不足时）

**命名约定**（遵循现有代码库）:
- 函数/方法: `snake_case`
- 类: `PascalCase`
- 常量: `UPPER_SNAKE_CASE`
- 异步函数: `async def` + `await`

**数据库访问模式**:
```python
from sqlalchemy import select, and_, func
from sqlalchemy.ext.asyncio import AsyncSession

# 查询模式
stmt = select(Model).where(
    and_(
        Model.field1 == value1,
        Model.field2 == value2
    )
).order_by(Model.date.desc()).limit(1)

result = await session.execute(stmt)
data = result.scalar_one_or_none()
```

**错误处理模式**:
```python
try:
    # 操作
    await session.commit()
    return {"success": True, ...}
except Exception as e:
    logger.error(f"操作失败: {e}")
    await session.rollback()
    return {"success": False, "error": str(e)}
```

## Dev Agent Record

### Context Reference

<!-- Path(s) to story context XML will be added here by context workflow -->

### Agent Model Used

glm-4.7

### Completion Notes

**故事上下文增强完成** (2025-12-28)

1. **前置故事学习** (Story 10.1):
   - 数据库表结构已完成优化
   - `get_strength_grade()` 函数已在 `server/src/config/calculation.py` 中定义
   - 迁移文件: `server/alembic/versions/2025_12_28_2126-d1a36df87bdc_optimize_strength_scores_table_for_ma_.py`

2. **架构分析**:
   - 现有服务模式: `server/src/services/stock_ma_service.py`
   - 现有计算器模式: `server/src/services/calculation/strength_calculator.py`
   - 数据库模型: `server/src/models/strength_score.py`

3. **增强的开发者上下文**:
   - 添加了架构和编码模式参考
   - 添加了数据库访问模式示例
   - 添加了错误处理模式示例
   - 命名约定明确（snake_case, PascalCase, UPPER_SNAKE_CASE）

4. **状态更新**:
   - Story 10.2 状态已更新为 `ready-for-dev`
   - sprint-status.yaml 已同步更新

**Story 10.2 实现完成** (2025-12-28)

实现了基于均线系统的两维度强度计算引擎：

1. **价格位置得分计算器** (`price_position_scorer.py`):
   - 实现 `calculate_score(ratio)` 函数，按比率区间返回 0-100 分
   - 实现 `calculate_weighted_score(price, ma_values)` 加权平均计算
   - 使用 MA_WEIGHTS 配置（8条均线权重总和为 1.0）

2. **均线排列评分器** (`ma_alignment_scorer.py`):
   - 检测 8 个关系：价格 > MA5, MA5 > MA10 > ... > MA240
   - 根据多头排列符合数量返回得分和状态
   - 状态包括: perfect_bull, strong_bull, bull, neutral, bear, perfect_bear

3. **综合强度计算器** (`strength_calculator_v2.py`):
   - 综合公式: (价格位置得分 + 均线排列得分) / 2
   - 计算短中长期强度（基于 TERM_GROUPS 分组）
   - 返回完整结果：composite_score, short_term_score, medium_term_score, long_term_score, strength_grade, price_positions, price_above_flags

4. **数据加载器** (`ma_data_loader.py`):
   - 从 `moving_average_data` 表读取 8 条均线数据
   - 从 `daily_market_data` 表读取当前价格
   - 实现数据缓存优化（可选启用）
   - 支持检查可用数据天数

5. **主计算服务** (`strength_service_v2.py`):
   - 实现 `calculate_stock_strength()` 个股强度计算
   - 实现 `calculate_sector_strength()` 板块强度计算
   - 实现 `batch_calculate()` 批量计算
   - 结果自动保存到 `strength_scores` 表（period='all'）

6. **配置文件** (`config/ma_system.py`):
   - MA_PERIODS: [5, 10, 20, 30, 60, 90, 120, 240]
   - MA_WEIGHTS: 8 条均线权重配置
   - TERM_GROUPS: 短中长期分组
   - STRENGTH_GRADES: 10 级强度等级定义（S+/S/A+/A/B+/B/C+/C/D+/D）

7. **单元测试** (`tests/test_ma_system_calculator.py`):
   - 35 个测试用例全部通过
   - 测试覆盖：价格位置得分、均线排列得分、综合强度、边界条件、数据不足处理

## File List

### 新增文件
- `server/src/config/ma_system.py` - 均线系统配置常量
- `server/src/services/calculation/ma_system/__init__.py` - 模块初始化
- `server/src/services/calculation/ma_system/price_position_scorer.py` - 价格位置得分计算器
- `server/src/services/calculation/ma_system/ma_alignment_scorer.py` - 均线排列评分器
- `server/src/services/calculation/ma_system/strength_calculator_v2.py` - 综合强度计算器
- `server/src/services/calculation/ma_system/ma_data_loader.py` - 数据加载器
- `server/src/services/strength_service_v2.py` - 主计算服务
- `server/tests/test_ma_system_calculator.py` - 单元测试

### 修改文件
- `docs/sprint-artifacts/sprint-status.yaml` - 更新故事状态
- `docs/stories/10.2.ma-system-strength-calculator.md` - 故事文件

---

## Code Review Results (2025-12-28)

### 发现的问题

#### 🔴 HIGH 严重问题 (已修复)

1. **N+1 查询性能问题** (`ma_data_loader.py:86-104`)
   - 问题: 为每个周期执行单独的数据库查询（8个周期 = 8次查询）
   - 修复: 改为单次查询获取所有周期数据，使用 Python 处理结果

2. **内存浪费问题** (`ma_data_loader.py:208-221`)
   - 问题: `_get_available_days()` 加载所有历史数据到内存仅为了计数
   - 修复: 使用数据库聚合函数 `func.count()`

3. **板块强度缺少渐近式逻辑** (`strength_service_v2.py:177`)
   - 问题: 个股计算有数据不足处理，板块计算没有
   - 修复: 添加了相同的渐近式计算逻辑

#### 🟡 MEDIUM 问题 (已修复)

4. **类型注解错误** (`ma_data_loader.py:162`)
   - 问题: 使用 `any` 而非 `Any`
   - 修复: 改为 `Dict[str, Any]`

5. **未使用的导入** (`strength_service_v2.py:8`)
   - 问题: 导入了 `datetime` 但从未使用
   - 修复: 移除该导入

6. **缓存没有过期策略** (`ma_data_loader.py:37-38`)
   - 问题: 缓存永久存在，可能导致内存泄漏
   - 修复: 添加 `MAX_CACHE_SIZE = 1000` 和 FIFO 清理策略

7. **魔法数字硬编码** (`strength_service_v2.py`)
   - 问题: 最小数据天数 `5` 硬编码在多处
   - 修复: 添加配置常量 `MIN_DATA_DAYS` 和 `FULL_DATA_DAYS`

#### 🟢 LOW 问题（未修复，可选）

8. **空初始化方法** (`ma_alignment_scorer.py:25-27`) - 不影响功能

9. **冗余的 None 检查** (`price_position_scorer.py:100`) - 不影响功能

### 性能改进

- **查询优化**: 8次查询 → 1次查询（单只股票）
- **批量计算**: 100只股票从 800次查询 → 100次查询
- **内存优化**: `_get_available_days()` 不再加载历史数据
